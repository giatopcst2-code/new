<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify Stats Pro</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body { background: #0a0a0a; margin: 0; }
      .gradient-red { background: linear-gradient(135deg, #1a0000 0%, #0a0a0a 50%, #1a0000 100%); }
      .card-dark { background: rgba(26, 0, 0, 0.3); border: 1px solid rgba(220, 38, 38, 0.2); }
      .scrollbar-hide::-webkit-scrollbar { display: none; }
      .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect } = React;
        
        const SpotifyStats = () => {
          const [token, setToken] = useState('');
          const [authed, setAuthed] = useState(false);
          const [range, setRange] = useState('short_term');
          const [customWeeks, setCustomWeeks] = useState('');
          const [showCustom, setShowCustom] = useState(false);
          const [data, setData] = useState(null);
          const [loading, setLoading] = useState(false);
          const [tab, setTab] = useState('tracks');
          const [search, setSearch] = useState('');
          const [results, setResults] = useState([]);
          const [detail, setDetail] = useState(null);
          const [allHistory, setAllHistory] = useState([]);
          const [allTopTracks, setAllTopTracks] = useState({ short: [], medium: [], long: [] });
          const [allTopArtists, setAllTopArtists] = useState({ short: [], medium: [], long: [] });

          const CID = '28a38a04492140ab9d521d62eed5f9d8';
          const REDIR = 'https://giatopcst2-code.github.io/new/';

          const genStr = (len) => {
            const p = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            const v = crypto.getRandomValues(new Uint8Array(len));
            return v.reduce((acc, x) => acc + p[x % p.length], "");
          };

          const sha = async (plain) => {
            const enc = new TextEncoder();
            const d = enc.encode(plain);
            return window.crypto.subtle.digest('SHA-256', d);
          };

          const b64 = (input) => {
            return btoa(String.fromCharCode(...new Uint8Array(input)))
              .replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
          };

          useEffect(() => {
            const params = new URLSearchParams(window.location.search);
            const code = params.get('code');
            if (code) {
              const ver = localStorage.getItem('code_verifier');
              if (ver) {
                exchange(code, ver);
              }
            }
          }, []);

          useEffect(() => {
            if (authed && token) {
              fetchAllData();
            }
          }, [authed, token]);

          useEffect(() => {
            if (authed && token && allHistory.length > 0) {
              processData();
            }
          }, [range, allHistory, allTopTracks, allTopArtists]);

          const exchange = async (code, ver) => {
            try {
              const res = await fetch('https://accounts.spotify.com/api/token', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: new URLSearchParams({
                  client_id: CID,
                  grant_type: 'authorization_code',
                  code: code,
                  redirect_uri: REDIR,
                  code_verifier: ver,
                }),
              });
              const json = await res.json();
              
              if (json.access_token) {
                setToken(json.access_token);
                setAuthed(true);
                localStorage.removeItem('code_verifier');
                window.history.replaceState({}, document.title, window.location.pathname);
              }
            } catch (e) {
              console.error('Exchange error:', e);
            }
          };

          const login = async () => {
            const ver = genStr(64);
            const hashed = await sha(ver);
            const challenge = b64(hashed);
            localStorage.setItem('code_verifier', ver);

            const scope = 'user-top-read user-read-recently-played user-library-read';
            const url = new URL("https://accounts.spotify.com/authorize");
            url.search = new URLSearchParams({
              response_type: 'code',
              client_id: CID,
              scope,
              code_challenge_method: 'S256',
              code_challenge: challenge,
              redirect_uri: REDIR,
            }).toString();
            window.location.href = url.toString();
          };

          const fetchAllData = async () => {
            setLoading(true);
            try {
              const h = { Authorization: `Bearer ${token}` };
              
              const recentRes = await fetch('https://api.spotify.com/v1/me/player/recently-played?limit=50', { headers: h });
              const recentData = await recentRes.json();
              setAllHistory(recentData.items || []);

              const [shortTracksRes, mediumTracksRes, longTracksRes] = await Promise.all([
                fetch('https://api.spotify.com/v1/me/top/tracks?time_range=short_term&limit=50', { headers: h }),
                fetch('https://api.spotify.com/v1/me/top/tracks?time_range=medium_term&limit=50', { headers: h }),
                fetch('https://api.spotify.com/v1/me/top/tracks?time_range=long_term&limit=50', { headers: h })
              ]);

              const shortTracks = await shortTracksRes.json();
              const mediumTracks = await mediumTracksRes.json();
              const longTracks = await longTracksRes.json();

              const [shortTracks2Res, mediumTracks2Res, longTracks2Res] = await Promise.all([
                fetch('https://api.spotify.com/v1/me/top/tracks?time_range=short_term&limit=50&offset=50', { headers: h }),
                fetch('https://api.spotify.com/v1/me/top/tracks?time_range=medium_term&limit=50&offset=50', { headers: h }),
                fetch('https://api.spotify.com/v1/me/top/tracks?time_range=long_term&limit=50&offset=50', { headers: h })
              ]);

              const shortTracks2 = await shortTracks2Res.json();
              const mediumTracks2 = await mediumTracks2Res.json();
              const longTracks2 = await longTracks2Res.json();

              setAllTopTracks({
                short: [...(shortTracks.items || []), ...(shortTracks2.items || [])],
                medium: [...(mediumTracks.items || []), ...(mediumTracks2.items || [])],
                long: [...(longTracks.items || []), ...(longTracks2.items || [])]
              });

              const [shortArtistsRes, mediumArtistsRes, longArtistsRes] = await Promise.all([
                fetch('https://api.spotify.com/v1/me/top/artists?time_range=short_term&limit=50', { headers: h }),
                fetch('https://api.spotify.com/v1/me/top/artists?time_range=medium_term&limit=50', { headers: h }),
                fetch('https://api.spotify.com/v1/me/top/artists?time_range=long_term&limit=50', { headers: h })
              ]);

              const shortArtists = await shortArtistsRes.json();
              const mediumArtists = await mediumArtistsRes.json();
              const longArtists = await longArtistsRes.json();

              const [shortArtists2Res, mediumArtists2Res, longArtists2Res] = await Promise.all([
                fetch('https://api.spotify.com/v1/me/top/artists?time_range=short_term&limit=50&offset=50', { headers: h }),
                fetch('https://api.spotify.com/v1/me/top/artists?time_range=medium_term&limit=50&offset=50', { headers: h }),
                fetch('https://api.spotify.com/v1/me/top/artists?time_range=long_term&limit=50&offset=50', { headers: h })
              ]);

              const shortArtists2 = await shortArtists2Res.json();
              const mediumArtists2 = await mediumArtists2Res.json();
              const longArtists2 = await longArtists2Res.json();

              setAllTopArtists({
                short: [...(shortArtists.items || []), ...(shortArtists2.items || [])],
                medium: [...(mediumArtists.items || []), ...(mediumArtists2.items || [])],
                long: [...(longArtists.items || []), ...(longArtists2.items || [])]
              });

            } catch (e) {
              console.error('Fetch error:', e);
            }
            setLoading(false);
          };

          const processData = () => {
            const now = new Date();
            let cutoffDate;
            let topTracks = [];
            let topArtists = [];
            let daysInRange = 0;

            if (range === 'short_term') {
              cutoffDate = new Date(now.getTime() - (7 * 24 * 60 * 60 * 1000));
              topTracks = allTopTracks.short;
              topArtists = allTopArtists.short;
              daysInRange = 7;
            } else if (range === 'medium_term') {
              cutoffDate = new Date(now.getTime() - (28 * 24 * 60 * 60 * 1000));
              topTracks = allTopTracks.short;
              topArtists = allTopArtists.short;
              daysInRange = 28;
            } else if (range === 'long_term') {
              cutoffDate = new Date(now.getTime() - (180 * 24 * 60 * 60 * 1000));
              topTracks = allTopTracks.medium;
              topArtists = allTopArtists.medium;
              daysInRange = 180;
            } else if (range === 'lifetime') {
              cutoffDate = new Date('2000-01-01');
              topTracks = allTopTracks.long;
              topArtists = allTopArtists.long;
              daysInRange = 0;
            } else if (range.startsWith('custom_')) {
              const weeks = parseInt(range.split('_')[1]);
              daysInRange = weeks * 7;
              cutoffDate = new Date(now.getTime() - (daysInRange * 24 * 60 * 60 * 1000));
              
              if (weeks <= 4) {
                topTracks = allTopTracks.short;
                topArtists = allTopArtists.short;
              } else if (weeks <= 26) {
                topTracks = allTopTracks.medium;
                topArtists = allTopArtists.medium;
              } else {
                topTracks = allTopTracks.long;
                topArtists = allTopArtists.long;
              }
            }

            const filteredHistory = allHistory.filter(item => 
              new Date(item.played_at) >= cutoffDate
            );

            const trackPlayCounts = {};
            const artistPlayCounts = {};
            let totalListeningTime = 0;

            filteredHistory.forEach(item => {
              const trackId = item.track.id;
              trackPlayCounts[trackId] = (trackPlayCounts[trackId] || 0) + 1;
              totalListeningTime += item.track.duration_ms;

              item.track.artists.forEach(artist => {
                artistPlayCounts[artist.id] = (artistPlayCounts[artist.id] || 0) + 1;
              });
            });

            const trackHistoryMap = {};
            allHistory.forEach(item => {
              const trackId = item.track.id;
              if (!trackHistoryMap[trackId]) {
                trackHistoryMap[trackId] = [];
              }
              trackHistoryMap[trackId].push(item);
            });

            // ESTIMATE plays based on ranking for better accuracy
            const enhancedTracks = topTracks.slice(0, 100).map((track, index) => {
              const history = trackHistoryMap[track.id] || [];
              const actualPlays = trackPlayCounts[track.id] || 0;
              
              // Estimate based on position: higher position = more plays
              // Top track gets estimated 100-150 plays per week
              // Scale down logarithmically
              let estimatedPlays = actualPlays;
              
              if (daysInRange > 0 && actualPlays === 0) {
                const baseMultiplier = daysInRange / 7; // plays per week factor
                const rankFactor = Math.max(1, (101 - index) / 10); // higher rank = more plays
                estimatedPlays = Math.round(rankFactor * baseMultiplier * 5);
              } else if (actualPlays > 0 && daysInRange > 0) {
                // If we have some actual data, extrapolate
                const daysOfData = Math.min(7, daysInRange); // assume recent history is ~7 days
                const extrapolationFactor = daysInRange / daysOfData;
                estimatedPlays = Math.round(actualPlays * extrapolationFactor);
              }
              
              let firstPlayed = null;
              let lastPlayed = null;
              
              if (history.length > 0) {
                const dates = history.map(item => new Date(item.played_at));
                firstPlayed = new Date(Math.min(...dates));
                lastPlayed = new Date(Math.max(...dates));
              }

              return {
                ...track,
                rank: index + 1,
                playCount: estimatedPlays,
                totalPlays: history.length,
                firstPlayed,
                lastPlayed,
                history
              };
            });

            // Calculate estimated listening time based on estimated plays
            let estimatedListeningTime = 0;
            if (daysInRange > 0) {
              enhancedTracks.forEach(track => {
                estimatedListeningTime += track.duration_ms * track.playCount;
              });
            } else {
              estimatedListeningTime = 0; // For lifetime
            }

            const enhancedArtists = topArtists.slice(0, 100).map((artist, index) => {
              const actualPlays = artistPlayCounts[artist.id] || 0;
              
              let estimatedPlays = actualPlays;
              if (daysInRange > 0 && actualPlays === 0) {
                const baseMultiplier = daysInRange / 7;
                const rankFactor = Math.max(1, (101 - index) / 8);
                estimatedPlays = Math.round(rankFactor * baseMultiplier * 8);
              } else if (actualPlays > 0 && daysInRange > 0) {
                const daysOfData = Math.min(7, daysInRange);
                const extrapolationFactor = daysInRange / daysOfData;
                estimatedPlays = Math.round(actualPlays * extrapolationFactor);
              }
              
              let totalPlays = 0;
              allHistory.forEach(item => {
                if (item.track.artists.some(a => a.id === artist.id)) {
                  totalPlays++;
                }
              });

              return {
                ...artist,
                rank: index + 1,
                playCount: estimatedPlays,
                totalPlays
              };
            });

            const albumsMap = {};
            enhancedTracks.forEach(track => {
              const albumId = track.album.id;
              if (!albumsMap[albumId]) {
                albumsMap[albumId] = {
                  album: track.album,
                  playCount: 0,
                  totalPlays: 0,
                  tracks: []
                };
              }
              albumsMap[albumId].playCount += track.playCount;
              albumsMap[albumId].totalPlays += track.totalPlays;
              albumsMap[albumId].tracks.push(track);
            });

            const albums = Object.values(albumsMap)
              .sort((a, b) => b.playCount - a.playCount)
              .slice(0, 100)
              .map((item, index) => ({
                ...item,
                rank: index + 1
              }));

            const genreCount = {};
            enhancedArtists.forEach(artist => {
              artist.genres.forEach(genre => {
                genreCount[genre] = (genreCount[genre] || 0) + 1;
              });
            });

            const genres = Object.entries(genreCount)
              .sort((a, b) => b[1] - a[1])
              .slice(0, 100)
              .map(([genre, count], index) => ({ 
                rank: index + 1,
                genre, 
                count 
              }));

            setData({
              tracks: enhancedTracks,
              artists: enhancedArtists,
              albums,
              genres,
              time: estimatedListeningTime,
              cutoffDate,
              trackHistoryMap
            });
          };

          const doSearch = async () => {
            if (!search.trim()) return;
            setResults([]);
            try {
              const h = { Authorization: `Bearer ${token}` };
              const res = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(search)}&type=track&limit=50`, { headers: h });
              const json = await res.json();
              
              const enhancedResults = (json.tracks?.items || []).map(track => {
                const history = allHistory.filter(item => item.track.id === track.id);
                
                let firstPlayed = null;
                let lastPlayed = null;
                let totalPlays = history.length;
                
                if (history.length > 0) {
                  const dates = history.map(item => new Date(item.played_at));
                  firstPlayed = new Date(Math.min(...dates));
                  lastPlayed = new Date(Math.max(...dates));
                }

                return {
                  ...track,
                  totalPlays,
                  firstPlayed,
                  lastPlayed,
                  history
                };
              });

              setResults(enhancedResults);
            } catch (e) {
              console.error('Search error:', e);
            }
          };

          const showDetail = async (track) => {
            setDetail(null);
            try {
              const h = { Authorization: `Bearer ${token}` };
              
              const audioRes = await fetch(`https://api.spotify.com/v1/audio-features/${track.id}`, { headers: h });
              const audio = await audioRes.json();

              const artistPlays = {};
              track.artists.forEach(artist => {
                let totalPlays = 0;
                allHistory.forEach(item => {
                  if (item.track.artists.some(a => a.id === artist.id)) {
                    totalPlays++;
                  }
                });
                artistPlays[artist.id] = totalPlays;
              });

              setDetail({
                ...track,
                audio,
                artistPlays
              });
            } catch (e) {
              console.error('Detail error:', e);
            }
          };

          const applyCustomRange = () => {
            const weeks = parseInt(customWeeks);
            if (isNaN(weeks) || weeks < 1) {
              alert('Please enter a valid number of weeks (minimum 1)');
              return;
            }
            setRange(`custom_${weeks}`);
            setShowCustom(false);
          };

          const fmtDur = (ms) => {
            if (range === 'lifetime') {
              return '-';
            }
            
            const totalMinutes = Math.floor(ms / 60000);
            const h = Math.floor(totalMinutes / 60);
            const m = totalMinutes % 60;
            
            if (h > 0) {
              return `${h}h ${m}m`;
            } else {
              return `${m}m`;
            }
          };

          const fmtTime = (ms) => {
            const m = Math.floor(ms / 60000);
            const s = Math.floor((ms % 60000) / 1000);
            return `${m}:${s.toString().padStart(2, '0')}`;
          };

          const fmtDate = (d) => {
            if (!d) return 'Not available';
            const date = new Date(d);
            if (isNaN(date.getTime())) return 'Not available';
            return date.toLocaleDateString('en-US', { 
              year: 'numeric', 
              month: 'long', 
              day: 'numeric' 
            });
          };

          const fmtDateTime = (d) => {
            if (!d) return 'Not available';
            const date = new Date(d);
            if (isNaN(date.getTime())) return 'Not available';
            return date.toLocaleString('en-US', { 
              year: 'numeric', 
              month: 'short', 
              day: 'numeric',
              hour: '2-digit',
              minute: '2-digit'
            });
          };

          const getRangeLabel = () => {
            if (range === 'short_term') return '1 Week';
            if (range === 'medium_term') return '4 Weeks';
            if (range === 'long_term') return '6 Months';
            if (range === 'lifetime') return 'All Time';
            if (range.startsWith('custom_')) {
              const weeks = range.split('_')[1];
              return `${weeks} Week${weeks > 1 ? 's' : ''}`;
            }
            return '';
          };

          const ranges = [
            { value: 'short_term', label: '1 Week' },
            { value: 'medium_term', label: '4 Weeks' },
            { value: 'long_term', label: '6 Months' },
            { value: 'lifetime', label: 'All Time' }
          ];

          if (!authed) {
            return (
              <div className="min-h-screen gradient-red flex items-center justify-center p-4">
                <div className="card-dark rounded-3xl shadow-2xl p-12 max-w-md w-full text-center backdrop-blur-sm">
                  <div className="bg-gradient-to-br from-red-600 to-red-900 w-24 h-24 rounded-full flex items-center justify-center mx-auto mb-6">
                    <svg className="w-12 h-12 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3" />
                    </svg>
                  </div>
                  <h1 className="text-5xl font-bold text-white mb-4">Spotify Stats Pro</h1>
                  <p className="text-gray-400 mb-8 text-lg">Complete analytics with all premium features - 100% free</p>
                  <button onClick={login} className="bg-gradient-to-r from-red-600 to-red-800 hover:from-red-700 hover:to-red-900 text-white font-semibold py-4 px-10 rounded-full text-lg transition-all transform hover:scale-105 shadow-lg">
                    Connect with Spotify
                  </button>
                </div>
              </div>
            );
          }

          return (
            <div className="min-h-screen gradient-red">
              <div className="bg-gradient-to-r from-red-900 to-black text-white p-8 shadow-2xl border-b border-red-800">
                <div className="max-w-7xl mx-auto">
                  <h1 className="text-5xl font-bold mb-2">Your Spotify Stats Pro</h1>
                  <p className="text-gray-400 mb-6">Viewing stats for: {getRangeLabel()}</p>
                  
                  <div className="flex gap-3 flex-wrap mb-4">
                    {ranges.map(r => (
                      <button 
                        key={r.value} 
                        onClick={() => setRange(r.value)} 
                        className={`px-6 py-3 rounded-full font-medium transition-all ${range === r.value ? 'bg-red-600 shadow-lg scale-105' : 'bg-red-900/30 hover:bg-red-900/50 border border-red-800'}`}
                      >
                        {r.label}
                      </button>
                    ))}
                    <button 
                      onClick={() => setShowCustom(!showCustom)}
                      className={`px-6 py-3 rounded-full font-medium transition-all ${range.startsWith('custom_') ? 'bg-red-600 shadow-lg scale-105' : 'bg-red-900/30 hover:bg-red-900/50 border border-red-800'}`}
                    >
                      Custom Range
                    </button>
                  </div>

                  {showCustom && (
                    <div className="flex gap-3 mb-4 items-center">
                      <input 
                        type="number" 
                        min="1"
                        placeholder="Enter weeks (min 1)" 
                        value={customWeeks}
                        onChange={(e) => setCustomWeeks(e.target.value)}
                        className="px-4 py-2 rounded-full bg-black/50 border border-red-800 text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-red-600 w-48"
                      />
                      <button 
                        onClick={applyCustomRange}
                        className="px-6 py-2 bg-red-600 hover:bg-red-700 rounded-full font-semibold"
                      >
                        Apply
                      </button>
                    </div>
                  )}

                  <div className="flex gap-3 mb-6">
                    <input 
                      type="text" 
                      placeholder="Search for any track..." 
                      value={search} 
                      onChange={(e) => setSearch(e.target.value)} 
                      onKeyPress={(e) => e.key === 'Enter' && doSearch()} 
                      className="flex-1 px-6 py-3 rounded-full bg-black/50 border border-red-800 text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-red-600" 
                    />
                    <button onClick={doSearch} className="px-8 py-3 bg-red-600 hover:bg-red-700 rounded-full font-semibold">Search</button>
                  </div>
                </div>
              </div>

              {loading ? (
                <div className="flex flex-col items-center justify-center h-64">
                  <div className="animate-spin rounded-full h-16 w-16 border-b-4 border-red-600 mb-4"></div>
                  <p className="text-gray-400">Loading your complete stats...</p>
                </div>
              ) : (
                <>
                  {results.length > 0 && (
                    <div className="max-w-7xl mx-auto p-8">
                      <div className="card-dark rounded-2xl p-6 backdrop-blur-sm mb-8">
                        <div className="flex justify-between items-center mb-6">
                          <h2 className="text-3xl font-bold text-white">Search Results</h2>
                          <button 
                            onClick={() => setResults([])}
                            className="text-gray-400 hover:text-white"
                          >
                            Clear
                          </button>
                        </div>
                        <div className="space-y-3">
                          {results.map((t) => (
                            <div key={t.id} onClick={() => showDetail(t)} className="flex items-center gap-4 p-4 rounded-xl hover:bg-red-900/20 transition cursor-pointer">
                              <img src={t.album.images[0]?.url} alt={t.name} className="w-16 h-16 rounded-lg" />
                              <div className="flex-1">
                                <p className="font-semibold text-white text-lg">{t.name}</p>
                                <p className="text-gray-400">{t.artists.map(a => a.name).join(', ')}</p>
                              </div>
                              <div className="text-right">
                                <p className="text-red-500 font-bold">{t.totalPlays || 0} plays</p>
                                  <p className="text-gray-500 text-sm">{item.tracks.length} tracks</p>
                                </div>
                              </div>
                            ))}
                          </div>
                        </div>
                      )}

                      {tab === 'genres' && (
                        <div className="card-dark rounded-2xl p-6 backdrop-blur-sm">
                          <h2 className="text-3xl font-bold text-white mb-6">Top 100 Genres</h2>
                          <div className="space-y-4">
                            {data.genres.map((g, i) => (
                              <div key={g.genre} className="flex items-center gap-4">
                                <div className="text-2xl font-bold text-red-600 w-12 text-center">{i + 1}</div>
                                <div className="flex-1">
                                  <div className="flex justify-between mb-2">
                                    <span className="font-semibold text-white text-lg capitalize">{g.genre}</span>
                                    <span className="text-gray-400">{g.count} artists</span>
                                  </div>
                                  <div className="w-full bg-black/50 rounded-full h-3">
                                    <div className="bg-gradient-to-r from-red-600 to-red-800 h-3 rounded-full" style={{ width: `${(g.count / data.genres[0].count) * 100}%` }}></div>
                                  </div>
                                </div>
                              </div>
                            ))}
                          </div>
                        </div>
                      )}
                    </div>
                  )}
                </>
              )}
            </div>
          );
        };

        ReactDOM.render(<SpotifyStats />, document.getElementById('root'));
    </script>
</body>
</html>
